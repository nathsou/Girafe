If(True, a, b) -> !(a)
If(False, a, b) -> !(b)
!(If(cond, a, b)) -> If(!(cond), a, b)

Not(True) -> False
Not(False) -> True
Not(Not(q)) -> q

And(False, False) -> False
And(False, True) -> False
And(True, False) -> False
And(True, True) -> True

Or(False, False) -> False
Or(False, True) -> True
Or(True, False) -> True
Or(True, True) -> True

+(a, b) -> @add(a, b)
-(a, b) -> @sub(a, b)
*(a, b) -> @mult(a, b)
/(a, b) -> @div(a, b)
%(a, b) -> @mod(a, b)
=(a, b) -> @equ(a, b)
>(a, b) -> @gtr(a, b)
>=(a, b) -> @geq(a, b)
<(a, b) -> @lss(a, b)
<=(a, b) -> @leq(a, b)

// iterators and lists

Range(from, to) -> If(=(from, to), It(to, EmptyIt), It(from, &Range(+(from, 1), to)))
!(&Range(from, to)) -> Range(from, to)

Next(It(val, next)) -> !(next)

Rev(&Rev(lst)) -> lst

List(it) -> List'(it, Nil)
List'(EmptyIt, lst) -> Rev(lst)
List'(It(n, next), lst) -> List'(!(next), :(n, lst))

Rev(lst) -> Rev'(lst, Nil)
Rev'(Nil, rev) -> rev
Rev'(:(h, tl), rev) -> Rev'(tl, :(h, rev))

Take(0, it) -> EmptyIt
Take(n, It(val, next)) -> It(val, &Take(-(n, 1), next))
!(&Take(n, it)) -> Take(n, !(it))

Len(it) -> Len'(it, 0)
Len'(EmptyIt, len) -> len 
Len'(It(h, next), len) -> Len'(!(next), +(len, 1))

Map(f, EmptyIt) -> EmptyIt
Map(f, It(h, next)) -> It(App(f, h), &Map(f, next))
!(&Map(f, next)) -> Map(f, !(next))

Foldl(f, EmptyIt, acc) -> acc
Foldl(f, It(n, next), acc) -> Foldl(f, !(next), App(App(f, acc), n))

App(App(Plus, a), b) -> +(a, b)
App(App(Mult, a), b) -> *(a, b)

App(Inc, n) -> +(n, 1)

IsDivisible(a, b) -> =(%(a, b), 0)
IsEven(n) -> IsDivisible(n, 2)

Collatz(1) -> It(1, EmptyIt)
Collatz(n) -> It(n, &Collatz(If(IsEven(n), /(n, 2), +(*(3, n), 1))))
!(&Collatz(n)) -> Collatz(n)

Max(It(n, next)) -> Max'(!(next), n)
Max'(EmptyIt, max) -> max
Max'(It(n, next), max) -> Max'(!(next), If(>(n, max), n, max))

// Binary trees

Ins(Leaf, key, val) -> Node(Entry(key, val), Leaf, Leaf)
Ins(Node(Entry(n, v), left, right), key, val) -> 
    If(<(key, n),
        &Node(Entry(n, v), &Ins(left, key, val), right),
        &Node(Entry(n, v), left, &Ins(right, key, val))
    )
!(&Node(n, left, right)) -> Node(n, !(left), !(right))
!(&Ins(dict, key, val)) -> Ins(dict, key, val)

Lookup(Leaf, key) -> None
Lookup(Node(Entry(k, v), left, right), key) ->
    If(=(key, k), 
        Some(v),
        If(<(key, k),
            &Lookup(left, key),
            &Lookup(right, key)
        )
    )
!(&Lookup(dict, key)) -> Lookup(dict, key)

IsSome(None) -> False
IsSome(Some(x)) -> True

Has(dict, key) -> IsSome(Lookup(dict, key))

T -> Ins(Ins(Ins(Leaf, 27, Len(Collatz(27))), 32, Len(Collatz(32))), 19, Len(Collatz(19)))

Query -> Foldl(Mult, Range(1, 10), 1)

// thunk instanciation
!(x) -> x