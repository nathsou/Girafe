import { Fun, Rule, StringMap, Substitution, Symb, Term, TRS, Var } from "../Parser/Types";
import { CompilerPass } from "./Passes/CompilerPass";
export declare type Maybe<T> = T | void;
export declare const logTRS: CompilerPass;
export declare const defaultPasses: CompilerPass[];
export declare function isFun(term: Term, name?: Symb): term is Fun;
export declare function isVar(term: Term, name?: Var): term is Var;
export declare function vars(term: Term, acc?: Var[]): Var[];
export declare function occurs(x: Var, t: Term): boolean;
export declare function isNothing<T>(m: Maybe<T>): m is void;
export declare function isSomething<T>(m: Maybe<T>): m is T;
export declare function substitute(t: Term, sigma: Substitution): Term;
export declare const termsEq: (a: Term, b: Term) => boolean;
export declare const rulesEq: ([lhs1, rhs1]: Rule, [lhs2, rhs2]: Rule) => boolean;
export declare function zip<T, U>(as: T[], bs: U[]): IterableIterator<[T, U]>;
export declare const hasRule: (trs: TRS, rule: Rule) => boolean;
export declare const addRules: (trs: TRS, ...rules: Rule[]) => void;
export declare const ruleName: ([lhs, _]: Rule) => Symb;
export declare const lhs: ([lhs, _]: Rule) => Fun;
export declare const rhs: ([_, rhs]: Rule) => Term;
export declare function uniq<T>(vals: T[]): T[];
export declare const ruleVars: ([lhs, rhs]: Rule) => Var[];
export declare const removeRules: (trs: TRS, ...rules: Rule[]) => void;
export declare const mapify: (rules: Rule[], trs?: TRS) => TRS;
export declare const unmapify: (trs: TRS) => Rule[];
export declare const showTRS: (trs: TRS) => string;
export declare const showTerm: (t: Term) => string;
export declare const showRule: ([lhs, rhs]: Rule) => string;
export declare const showSubst: (sigma: Substitution) => string;
export declare const cloneTRS: (trs: TRS) => TRS;
export declare const emptyTRS: () => TRS;
export declare const arity: (rules: Rule[]) => number;
export declare const ruleArity: ([lhs, _]: Rule) => number;
export declare const fun: (name: Symb, ...args: Term[]) => Fun;
export declare function genVars(n: number): string[];
export declare const mostGeneralFun: (name: string, arity: number) => Fun;
export declare const isRuleMostGeneral: ([lhs, _]: Rule) => boolean;
export declare const hasMostGeneralRule: (rules: Rule[]) => boolean;
export declare const isRuleRecursive: ([lhs, rhs]: Rule) => boolean;
export declare const hasRecursiveRule: (rules: Rule[]) => boolean;
export declare function setDiff<T>(as: Set<T>, bs: Set<T>): Set<T>;
export declare type SetLike<T> = Set<T> | Map<T, any>;
export declare function setEq<T>(as: SetLike<T>, bs: SetLike<T>): boolean;
export declare function swapMut<T>(vals: T[], i: number, j: number): void;
export declare function swap<T>(vals: T[], i: number, j: number): T[];
export declare const unusedRuleVars: ([lhs, rhs]: Rule) => Set<string>;
export declare function fill<T>(val: T, count: number): T[];
export declare function occurences<T>(vals: T[]): Map<T, number[]>;
export declare function elem<T>(value: T, elems: T[], eq?: (a: T, b: T) => boolean): boolean;
export declare function hasDuplicates<T>(vals: T[], eq?: (a: T, b: T) => boolean): boolean;
export declare function hasDuplicatesSet<T>(vals: T[]): boolean;
export declare function hasDuplicatesMap<T>(vals: T[]): boolean;
export declare function head<T>(list: T[]): T;
export declare function last<T>(list: T[]): T;
export declare function tail<T>(list: T[]): T[];
export declare function decons<T>(list: T[]): [T, T[]];
export declare function split<T>(list: T[], splitIdx: number): [T[], T[]];
export declare function fst<T>(list: T[]): T;
export declare function snd<T>(list: T[]): T;
export declare function trd<T>(list: T[]): T;
export declare const replaceTerms: (old: Term, by: Term, inside: Term[]) => Term[];
export declare function isEmpty<T>(collection: T[] | Set<T>): boolean;
export declare const alphaEquiv: (s: Term, t: Term) => boolean;
export declare type AlphaSubst = StringMap<Var>;
export declare const alphaEquivAux: (eqs: [Term, Term][], sigma?: AlphaSubst) => Maybe<AlphaSubst>;
export declare const rulesAlphaEquiv: (rule1: Rule, rule2: Rule) => boolean;
